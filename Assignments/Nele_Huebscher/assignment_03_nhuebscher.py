# -*- coding: utf-8 -*-
"""03_Assignment_Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TQRrPMqDG-LYOO0WU15AOjhHG9SE23SO

# Assignment 03
#### Python Basics III - Functions and Classes

### Sorry fpr handing in late, was sick unfortunately (:

This tutorial was written by Terry L. Ruas (University of Göttingen). The references for external contributors for which this material was anyhow adapted/inspired are in the Acknowledgments section (end of the document).

This notebook will cover the following tasks:

1. Dictionary
2. Classes

## Task 01 – Dictionary - already finished in the given sheet, not mine (:
Imagine you have to write a (very simple) bookkeepingsystem for a bank that keeps track of the account balances of each of its customers.
1. Write a function that spans a dictionary holding a default balance of 0 for an initial list of customers. For simplicity, assume customer names are unique identifier.  (optional) Can you express that same functionality using a lambda function?
2. What are elegant ways to add or remove single and multiple customers using the functionality of dict?
3. Now write two simple functions that allow you to deposit and withdraw money for a given bank customer.
4. Include error messages for inputs that are not permissible, e.g., withdrawing negative amounts or overdrawing the account, etc.
"""

#initial list of customers
customers = ['alice','bob','cecile']

#make a dict with balance 0 for each customer
def initiaslise_balance(cust):
    b = {c: 0 for c in cust}
    return b

balance = initiaslise_balance(customers)


#optional: lambda calc way to initialise dict
#alt_balance = dict(map(lambda x: 0, customers))

balance

balance['zach'] = 0
balance['bob'] = 15
balance

#single:
#add
new_user = 'david'
balance[new_user] = 0
print(balance)
#remove
balance.pop(new_user,'Warning: user did not exist!')
print(balance)

#multiple: same, but with dict comp
#add
new_users = ['david','ethan','fiona']
balance.update({c:0 for c in new_users})
print(balance)
[balance.pop(user,f'Warning: user {user} did not exist') for user in new_users]
#for user in new_users:
#    balance.pop(user,'not found')

print(balance)

def add_money(accounts, user, amount):
    if user not in accounts:
        print(f'user {user} not found, aborting')
    elif type(amount) != int and type(amount) != float:
        print('non-numeric input, aborting')
    elif amount < 0:
        print('cannot add negative money, aborting...')
    else:
        print('transaction successful')
        accounts[user] += amount
    return accounts

def withdraw_money(accounts, user, amount):
    if user not in accounts:
        print(f'user {user} not found, aborting')
    elif type(amount) != int and type(amount) != float:
        print('non-numeric input, aborting')
    elif amount > accounts[user]:
        print('overdrawing not permitted! aborting')
    else:
        print('transaction successful')
        accounts[user] -= amount
    return accounts

balance = add_money(balance, 'alice', 50)
balance = add_money(balance, 'cecile', -5)
balance = add_money(balance, 'anna', 5)

balance = withdraw_money(balance, 'alice', 15)
balance = withdraw_money(balance, 'bob', 15)
balance = withdraw_money(balance, 'felix', 15)

print(f'\n{balance}')

"""
## Task 02 – Classes
The manager thinks that the simple bookkeeping system you have built is not powerful enough. She requests that you start from scratch and use classes instead.
1. Write a simple class with appropriate constructor *\_\_init\_\_* that initializes an object of class *Customer* tracking the same information as in Task 01.
2. Now write two simple methods for class *Customer* that allow you to deposit and withdraw money for a given customer object.
3. Include error messages for inputs that are not permissible, e.g., withdrawing negative amounts or overdrawing the account.
4. (Inheritance) Write a child class *SavingsCustomer* that inherits its features from the parent class *Customer*. A savings customer has an extra savings balance for receiving extra interest. The class should have a method to transfer money back and forth between the accounts' main balance as well as the savings balance. Do not forget to add reasonable error messages."""

class Customer:
    # Constructor
    def __init__(self, name, balance):
        self.name = name    # define name
        self.balance = balance # define balance

    def add_money(self, amount):
        if type(amount) != int and type(amount) != float:
            print('non-numeric input, aborting')
        elif amount < 0:
            print('cannot add negative money, aborting...')
        else:
            print('transaction successful')
            self.balance += amount

    def withdraw_money (self, amount):
        if type(amount) != int and type(amount) != float:
            print('non-numeric input, aborting')
        elif amount > self.balance:
            print('overdrawing not permitted! aborting')
        else:
            print('transaction successful')
            self.balance -= amount

class SavingsCustomer (Customer):

    def __init__(self, name, balance, savingsBalance):
        #super().__init__(name, balance)
        self.name = name    # define name
        self.balance = balance # define balance
        self.savingsBalance = savingsBalance # define savings

    def shift_money (self,fromAccount, amount):
        if (fromAccount == self.savingsBalance):
            if (self.withdraw_money(self.savingsBalance, amount)):
                self.add_money(self.balance, amount)
        elif (fromAccount == 'balance'):
            if (self.withdraw_money(self.balance, amount)):
                self.add_money(self.savingsBalance, amount)
        else:
            print('Please insert from which money you like to shift money and then the amount of money')

    def add_money(self, account, amount):
        if type(amount) != int and type(amount) != float:
            print('non-numeric input, aborting')
        elif amount < 0:
            print('cannot add negative money, aborting...')
        else:
            print('transaction successful')
            if (account == self.savingsBalance):
                account += amount
                self.savingsBalance = account
            else:
                account += amount
                self.balance = account

    def withdraw_money (self, account, amount):
        if type(amount) != int and type(amount) != float:
            print('non-numeric input, aborting')
            return False
        elif amount > account:
            print('overdrawing not permitted! aborting')
            return False
        else:
            print('transaction successful')
            if (account == self.savingsBalance):
                account -= amount
                self.savingsBalance = account
            else:
                account -= amount
                self.balance = account
        return True
